import { __decorate, __metadata, __param } from 'tslib';
import { Input, ContentChild, Directive, EventEmitter, Output, Component, Inject, forwardRef, ContentChildren, QueryList, ViewChildren, TemplateRef, Pipe, ElementRef, Renderer, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

let DataTableColumn = class DataTableColumn {
    constructor() {
        this.sortable = false;
        this.resizable = false;
        this.visible = true;
        this.styleClassObject = {}; // for [ngClass]
    }
    getCellColor(row, index) {
        if (this.cellColors !== undefined) {
            return this.cellColors(row.item, row, this, index);
        }
    }
    ngOnInit() {
        this._initCellClass();
    }
    _initCellClass() {
        if (!this.styleClass && this.property) {
            if (/^[a-zA-Z0-9_]+$/.test(this.property)) {
                this.styleClass = 'column-' + this.property;
            }
            else {
                this.styleClass =
                    'column-' + this.property.replace(/[^a-zA-Z0-9_]/g, '');
            }
        }
        if (this.styleClass != null) {
            this.styleClassObject = {
                [this.styleClass]: true
            };
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], DataTableColumn.prototype, "header", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DataTableColumn.prototype, "sortable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DataTableColumn.prototype, "resizable", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DataTableColumn.prototype, "property", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DataTableColumn.prototype, "styleClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], DataTableColumn.prototype, "cellColors", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DataTableColumn.prototype, "width", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DataTableColumn.prototype, "visible", void 0);
__decorate([
    ContentChild('dataTableCell'),
    __metadata("design:type", Object)
], DataTableColumn.prototype, "cellTemplate", void 0);
__decorate([
    ContentChild('dataTableHeader'),
    __metadata("design:type", Object)
], DataTableColumn.prototype, "headerTemplate", void 0);
DataTableColumn = __decorate([
    Directive({
        selector: 'data-table-column'
    })
], DataTableColumn);

let DataTableRow = class DataTableRow {
    constructor(dataTable) {
        this.dataTable = dataTable;
        this._this = this; // FIXME is there no template keyword for this in angular 2?
        this.selectedChange = new EventEmitter();
    }
    get selected() {
        return this._selected;
    }
    set selected(selected) {
        this._selected = selected;
        this.selectedChange.emit(selected);
    }
    // other:
    get displayIndex() {
        if (this.dataTable.pagination) {
            return this.dataTable.displayParams.offset + this.index + 1;
        }
        else {
            return this.index + 1;
        }
    }
    getTooltip() {
        if (this.dataTable.rowTooltip) {
            return this.dataTable.rowTooltip(this.item, this, this.index);
        }
        return '';
    }
    ngOnDestroy() {
        this.selected = false;
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], DataTableRow.prototype, "item", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], DataTableRow.prototype, "index", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], DataTableRow.prototype, "selectedChange", void 0);
DataTableRow = __decorate([
    Component({
        selector: '[dataTableRow]',
        template: "<tr\n  class=\"data-table-row\"\n  [title]=\"getTooltip()\"\n  [style.background-color]=\"dataTable.getRowColor(item, index, _this)\"\n  [class.row-odd]=\"index % 2 === 0\"\n  [class.row-even]=\"index % 2 === 1\"\n  [class.selected]=\"selected\"\n  [class.clickable]=\"dataTable.selectOnRowClick\"\n  (dblclick)=\"dataTable.rowDoubleClicked(_this, $event)\"\n  (click)=\"dataTable.rowClicked(_this, $event)\"\n>\n  <td [hide]=\"!dataTable.expandColumnVisible\">\n    <div\n      tabindex=\"0\"\n      role=\"button\"\n      (click)=\"expanded = !expanded; $event.stopPropagation()\"\n      class=\"row-expand-button\"\n      [attr.aria-expanded]=\"expanded\"\n      [title]=\"dataTable.translations.expandRow\"\n      [attr.aria-label]=\"dataTable.translations.expandRow\"\n    >\n      <span\n        class=\"fa\"\n        [ngClass]=\"{\n          'fa-caret-right': !expanded,\n          'fa-caret-bottom': expanded\n        }\"\n        aria-hidden=\"true\"\n      ></span>\n    </div>\n  </td>\n  <td [hide]=\"!dataTable.indexColumnVisible\" class=\"index-column\">\n    {{ displayIndex }}\n  </td>\n  <td [hide]=\"!dataTable.selectColumnVisible\" class=\"select-column\">\n    <input type=\"checkbox\" [(ngModel)]=\"selected\" />\n  </td>\n  <td\n    *ngFor=\"let column of dataTable.columns\"\n    [hide]=\"!column.visible\"\n    [ngClass]=\"column.styleClassObject\"\n    class=\"data-column\"\n    [style.background-color]=\"column.getCellColor(_this, index)\"\n  >\n    <div *ngIf=\"!column.cellTemplate\">\n      {{ item[column.property] }}\n    </div>\n    <div\n      *ngIf=\"column.cellTemplate\"\n      [ngTemplateOutlet]=\"column.cellTemplate\"\n      [ngTemplateOutletContext]=\"{ column: column, row: _this, item: item }\"\n    ></div>\n  </td>\n</tr>\n<tr *ngIf=\"dataTable.expandableRows\" [hide]=\"!expanded\" class=\"row-expansion\">\n  <td [attr.colspan]=\"dataTable.columnCount\">\n    <div\n      [ngTemplateOutlet]=\"dataTable.expandTemplate\"\n      [ngTemplateOutletContext]=\"{ row: _this, item: item }\"\n    ></div>\n  </td>\n</tr>\n",
        styles: [".select-column{text-align:center}.row-expand-button{cursor:pointer;text-align:center}.clickable{cursor:pointer}"]
    }),
    __param(0, Inject(forwardRef(() => DataTable))),
    __metadata("design:paramtypes", [DataTable])
], DataTableRow);

const defaultTranslations = {
    headerReload: 'reload',
    headerColumnSelector: 'column selector',
    indexColumn: 'index',
    selectColumn: 'select',
    selectRow: 'select',
    selectAllRows: 'select',
    expandColumn: 'expand',
    expandRow: 'expand',
    paginationLimit: 'Limit',
    paginationRange: 'Results'
};

function drag(event, { move: move, up: up }) {
    const startX = event.pageX;
    const startY = event.pageY;
    let x = startX;
    let y = startY;
    let moved = false;
    function mouseMoveHandler(event) {
        const dx = event.pageX - x;
        const dy = event.pageY - y;
        x = event.pageX;
        y = event.pageY;
        if (dx || dy) {
            moved = true;
        }
        move(event, dx, dy, x, y);
        event.preventDefault(); // to avoid text selection
    }
    function mouseUpHandler(event) {
        x = event.pageX;
        y = event.pageY;
        document.removeEventListener('mousemove', mouseMoveHandler);
        document.removeEventListener('mouseup', mouseUpHandler);
        if (up) {
            up(event, x, y, moved);
        }
    }
    document.addEventListener('mousemove', mouseMoveHandler);
    document.addEventListener('mouseup', mouseUpHandler);
}

let DataTable = class DataTable {
    constructor() {
        this._items = [];
        this.header = true;
        this.pagination = true;
        this.pagination_range = false;
        this.pagination_limit = false;
        this.pagination_input = false;
        this.pagination_numbers = true;
        this.indexColumn = true;
        this.indexColumnHeader = '';
        this.selectColumn = false;
        this.multiSelect = true;
        this.substituteRows = true;
        this.expandableRows = false;
        this.translations = defaultTranslations;
        this.selectOnRowClick = false;
        this.autoReload = true;
        this.showReloading = false;
        this._sortAsc = true;
        this._offset = 0;
        this._limit = 10;
        // event handlers:
        this.rowClick = new EventEmitter();
        this.rowDoubleClick = new EventEmitter();
        this.headerClick = new EventEmitter();
        this.cellClick = new EventEmitter();
        // Reloading:
        this._reloading = false;
        this.reload = new EventEmitter();
        this._displayParams = {}; // params of the last finished reload
        this._scheduledReload = null;
        this.selectedRows = [];
        this._selectAllCheckbox = false;
        // column resizing:
        this._resizeInProgress = false;
        this.resizeLimit = 30;
    }
    get items() {
        return this._items;
    }
    set items(items) {
        this._items = items;
        this._onReloadFinished();
    }
    get sortBy() {
        return this._sortBy;
    }
    set sortBy(value) {
        this._sortBy = value;
        this._triggerReload();
    }
    get sortAsc() {
        return this._sortAsc;
    }
    set sortAsc(value) {
        this._sortAsc = value;
        this._triggerReload();
    }
    get offset() {
        return this._offset;
    }
    set offset(value) {
        this._offset = value;
        this._triggerReload();
    }
    get limit() {
        return this._limit;
    }
    set limit(value) {
        this._limit = value;
        this._triggerReload();
    }
    // calculated property:
    get page() {
        return Math.floor(this.offset / this.limit) + 1;
    }
    set page(value) {
        this.offset = (value - 1) * this.limit;
    }
    get lastPage() {
        return Math.ceil(this.itemCount / this.limit);
    }
    // setting multiple observable properties simultaneously
    sort(sortBy, asc) {
        this.sortBy = sortBy;
        this.sortAsc = asc;
    }
    // init
    ngOnInit() {
        this._initDefaultValues();
        this._initDefaultClickEvents();
        this._updateDisplayParams();
        if (this.autoReload && this._scheduledReload == null) {
            this.reloadItems();
        }
    }
    _initDefaultValues() {
        this.indexColumnVisible = this.indexColumn;
        this.selectColumnVisible = this.selectColumn;
        this.expandColumnVisible = this.expandableRows;
    }
    _initDefaultClickEvents() {
        this.headerClick.subscribe(tableEvent => this.sortColumn(tableEvent.column));
        if (this.selectOnRowClick) {
            this.rowClick.subscribe(tableEvent => (tableEvent.row.selected = !tableEvent.row.selected));
        }
    }
    get reloading() {
        return this._reloading;
    }
    reloadItems() {
        this._reloading = true;
        this.reload.emit(this._getRemoteParameters());
    }
    _onReloadFinished() {
        this._updateDisplayParams();
        this._selectAllCheckbox = false;
        this._reloading = false;
    }
    get displayParams() {
        return this._displayParams;
    }
    _updateDisplayParams() {
        this._displayParams = {
            sortBy: this.sortBy,
            sortAsc: this.sortAsc,
            offset: this.offset,
            limit: this.limit
        };
    }
    // for avoiding cascading reloads if multiple params are set at once:
    _triggerReload() {
        if (this._scheduledReload) {
            clearTimeout(this._scheduledReload);
        }
        this._scheduledReload = setTimeout(() => {
            this.reloadItems();
        });
    }
    rowClicked(row, event) {
        this.rowClick.emit({ row, event });
    }
    rowDoubleClicked(row, event) {
        this.rowDoubleClick.emit({ row, event });
    }
    headerClicked(column, event) {
        if (!this._resizeInProgress) {
            event.preventDefault();
            event.stopPropagation();
            this.headerClick.emit({ column, event });
        }
        else {
            this._resizeInProgress = false; // this is because I can't prevent click from mousup of the drag end
        }
    }
    cellClicked(column, row, event) {
        this.cellClick.emit({ row, column, event });
    }
    // functions:
    _getRemoteParameters() {
        let params = {};
        if (this.sortBy) {
            params.sortBy = this.sortBy;
            params.sortAsc = this.sortAsc;
        }
        if (this.pagination) {
            params.offset = this.offset;
            params.limit = this.limit;
        }
        return params;
    }
    sortColumn(column) {
        if (column.sortable) {
            let ascending = this.sortBy === column.property ? !this.sortAsc : true;
            this.sort(column.property, ascending);
        }
    }
    get columnCount() {
        let count = 0;
        count += this.indexColumnVisible ? 1 : 0;
        count += this.selectColumnVisible ? 1 : 0;
        count += this.expandColumnVisible ? 1 : 0;
        this.columns.toArray().forEach(column => {
            count += column.visible ? 1 : 0;
        });
        return count;
    }
    getRowColor(item, index, row) {
        if (this.rowColors !== undefined) {
            return this.rowColors(item, row, index);
        }
    }
    get selectAllCheckbox() {
        return this._selectAllCheckbox;
    }
    set selectAllCheckbox(value) {
        this._selectAllCheckbox = value;
        this._onSelectAllChanged(value);
    }
    _onSelectAllChanged(value) {
        this.rows.toArray().forEach(row => (row.selected = value));
    }
    onRowSelectChanged(row) {
        // maintain the selectedRow(s) view
        if (this.multiSelect) {
            let index = this.selectedRows.indexOf(row);
            if (row.selected && index < 0) {
                this.selectedRows.push(row);
            }
            else if (!row.selected && index >= 0) {
                this.selectedRows.splice(index, 1);
            }
        }
        else {
            if (row.selected) {
                this.selectedRow = row;
            }
            else if (this.selectedRow === row) {
                this.selectedRow = undefined;
            }
        }
        // unselect all other rows:
        if (row.selected && !this.multiSelect) {
            this.rows
                .toArray()
                .filter(row_ => row_.selected)
                .forEach(row_ => {
                if (row_ !== row) {
                    // avoid endless loop
                    row_.selected = false;
                }
            });
        }
    }
    // other:
    get substituteItems() {
        return Array.from({ length: this.displayParams.limit - this.items.length });
    }
    resizeColumnStart(event, column, columnElement) {
        this._resizeInProgress = true;
        drag(event, {
            move: (moveEvent, dx) => {
                if (this._isResizeInLimit(columnElement, dx)) {
                    column.width = columnElement.offsetWidth + dx;
                }
            }
        });
    }
    _isResizeInLimit(columnElement, dx) {
        /* This is needed because CSS min-width didn't work on table-layout: fixed.
         Without the limits, resizing can make the next column disappear completely,
         and even increase the table width. The current implementation suffers from the fact,
         that offsetWidth sometimes contains out-of-date values. */
        if ((dx < 0 && columnElement.offsetWidth + dx <= this.resizeLimit) ||
            !columnElement.nextElementSibling || // resizing doesn't make sense for the last visible column
            (dx >= 0 &&
                columnElement.nextElementSibling.offsetWidth + dx <=
                    this.resizeLimit)) {
            return false;
        }
        return true;
    }
};
__decorate([
    Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], DataTable.prototype, "items", null);
__decorate([
    Input(),
    __metadata("design:type", Number)
], DataTable.prototype, "itemCount", void 0);
__decorate([
    ContentChildren(DataTableColumn),
    __metadata("design:type", QueryList)
], DataTable.prototype, "columns", void 0);
__decorate([
    ViewChildren(DataTableRow),
    __metadata("design:type", QueryList)
], DataTable.prototype, "rows", void 0);
__decorate([
    ContentChild('dataTableExpand'),
    __metadata("design:type", TemplateRef)
], DataTable.prototype, "expandTemplate", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DataTable.prototype, "headerTitle", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DataTable.prototype, "header", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DataTable.prototype, "pagination", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DataTable.prototype, "pagination_range", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DataTable.prototype, "pagination_limit", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DataTable.prototype, "pagination_input", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DataTable.prototype, "pagination_numbers", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DataTable.prototype, "indexColumn", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DataTable.prototype, "indexColumnHeader", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], DataTable.prototype, "rowColors", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], DataTable.prototype, "rowTooltip", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DataTable.prototype, "selectColumn", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DataTable.prototype, "multiSelect", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DataTable.prototype, "substituteRows", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DataTable.prototype, "expandableRows", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DataTable.prototype, "translations", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DataTable.prototype, "selectOnRowClick", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DataTable.prototype, "autoReload", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DataTable.prototype, "showReloading", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DataTable.prototype, "noDataMessage", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], DataTable.prototype, "rowClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], DataTable.prototype, "rowDoubleClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], DataTable.prototype, "headerClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], DataTable.prototype, "cellClick", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], DataTable.prototype, "sortBy", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], DataTable.prototype, "sortAsc", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], DataTable.prototype, "offset", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], DataTable.prototype, "limit", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], DataTable.prototype, "page", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], DataTable.prototype, "reload", void 0);
DataTable = __decorate([
    Component({
        selector: 'data-table',
        template: "<div class=\"data-table-wrapper\">\n  <data-table-header *ngIf=\"header\"></data-table-header>\n\n  <div class=\"data-table-box\">\n    <table class=\"table table-condensed table-bordered data-table\">\n      <thead>\n        <tr>\n          <th\n            scope=\"col\"\n            [hide]=\"!expandColumnVisible\"\n            class=\"expand-column-header\"\n          ></th>\n          <th\n            scope=\"col\"\n            [hide]=\"!indexColumnVisible\"\n            class=\"index-column-header\"\n          >\n            <span>{{ indexColumnHeader }}</span>\n          </th>\n          <th\n            scope=\"col\"\n            [hide]=\"!selectColumnVisible\"\n            class=\"select-column-header\"\n          >\n            <input\n              [hide]=\"!multiSelect\"\n              type=\"checkbox\"\n              [(ngModel)]=\"selectAllCheckbox\"\n              [attr.aria-label]=\"translations.selectAllRows\"\n            />\n          </th>\n          <th\n            scope=\"col\"\n            *ngFor=\"let column of columns\"\n            #th\n            [hide]=\"!column.visible\"\n            (click)=\"headerClicked(column, $event)\"\n            (keyup.enter)=\"headerClicked(column, $event)\"\n            (keyup.space)=\"headerClicked(column, $event)\"\n            [class.sortable]=\"column.sortable\"\n            [class.resizable]=\"column.resizable\"\n            [ngClass]=\"column.styleClassObject\"\n            class=\"column-header\"\n            [style.width]=\"column.width | px\"\n            [attr.aria-sort]=\"\n              column.sortable\n                ? column.property === sortBy\n                  ? sortAsc\n                    ? 'ascending'\n                    : 'descending'\n                  : 'none'\n                : null\n            \"\n            [attr.tabindex]=\"column.sortable ? '0' : null\"\n          >\n            <span *ngIf=\"!column.headerTemplate\">\n              {{ column.header }}\n            </span>\n            <span\n              *ngIf=\"column.headerTemplate\"\n              [ngTemplateOutlet]=\"column.headerTemplate\"\n              [ngTemplateOutletContext]=\"{ column: column }\"\n            ></span>\n            <span class=\"column-sort-icon\" *ngIf=\"column.sortable\">\n              <span\n                class=\"fa fa-sort column-sortable-icon\"\n                [hide]=\"column.property === sortBy\"\n              ></span>\n              <span [hide]=\"column.property !== sortBy\">\n                <span\n                  class=\"fa\"\n                  [ngClass]=\"{\n                    'fa-caret-top': !sortAsc,\n                    'fa-caret-bottom': sortAsc\n                  }\"\n                ></span>\n              </span>\n            </span>\n            <span\n              *ngIf=\"column.resizable\"\n              class=\"column-resize-handle\"\n              (mousedown)=\"resizeColumnStart($event, column, th)\"\n            ></span>\n          </th>\n        </tr>\n      </thead>\n      <tbody\n        *ngFor=\"let item of items; let index = index\"\n        class=\"data-table-row-wrapper\"\n        dataTableRow\n        #row\n        [item]=\"item\"\n        [index]=\"index\"\n        (selectedChange)=\"onRowSelectChanged(row)\"\n      ></tbody>\n      <tbody *ngIf=\"itemCount === 0 && noDataMessage\">\n        <tr>\n          <td [attr.colspan]=\"columnCount\">{{ noDataMessage }}</td>\n        </tr>\n      </tbody>\n      <tbody class=\"substitute-rows\" *ngIf=\"pagination && substituteRows\">\n        <tr\n          *ngFor=\"let item of substituteItems; let index = index\"\n          [class.row-odd]=\"(index + items.length) % 2 === 0\"\n          [class.row-even]=\"(index + items.length) % 2 === 1\"\n        >\n          <td [hide]=\"!expandColumnVisible\"></td>\n          <td [hide]=\"!indexColumnVisible\">&nbsp;</td>\n          <td [hide]=\"!selectColumnVisible\"></td>\n          <td *ngFor=\"let column of columns\" [hide]=\"!column.visible\"></td>\n        </tr>\n      </tbody>\n    </table>\n    <div class=\"loading-cover\" *ngIf=\"showReloading && reloading\"></div>\n  </div>\n\n  <data-table-pagination\n    *ngIf=\"pagination\"\n    [show_range]=\"pagination_range\"\n    [show_limit]=\"pagination_limit\"\n    [show_input]=\"pagination_input\"\n    [show_numbers]=\"pagination_numbers\"\n  ></data-table-pagination>\n</div>\n",
        styles: [":host /deep/ .data-table.table>tbody+tbody{border-top:none}:host /deep/ .data-table.table td{vertical-align:middle}:host /deep/ .data-table>tbody>tr>td,:host /deep/ .data-table>thead>tr>th{overflow:hidden}:host /deep/ .row-odd{background-color:#f6f6f6}.data-table .substitute-rows>tr:hover,:host /deep/ .data-table .data-table-row:hover{background-color:#ececec}.data-table{box-shadow:0 0 15px #ececec;table-layout:fixed}.column-header{position:relative}.expand-column-header{width:50px}.select-column-header{width:50px;text-align:center}.index-column-header{width:40px}.column-header.sortable{cursor:pointer}.column-header .column-sort-icon{float:right}.column-header.resizable .column-sort-icon{margin-right:8px}.column-header .column-sort-icon .column-sortable-icon{color:#d3d3d3}.column-header .column-resize-handle{position:absolute;top:0;right:0;margin:0;padding:0;width:8px;height:100%;cursor:col-resize}.data-table-box{position:relative}.loading-cover{position:absolute;width:100%;height:100%;background-color:rgba(255,255,255,.3);top:0}"]
    })
], DataTable);

let DataTablePagination = class DataTablePagination {
    constructor(dataTable) {
        this.dataTable = dataTable;
        this.show_range = false;
        this.show_limit = false;
        this.show_input = false;
        this.show_numbers = true;
    }
    pageBack() {
        this.dataTable.offset -= Math.min(this.dataTable.limit, this.dataTable.offset);
    }
    pageForward() {
        this.dataTable.offset += this.dataTable.limit;
    }
    pageFirst() {
        this.dataTable.offset = 0;
    }
    pageLast() {
        this.dataTable.offset = (this.maxPage - 1) * this.dataTable.limit;
    }
    get maxPage() {
        return Math.ceil(this.dataTable.itemCount / this.dataTable.limit);
    }
    get limit() {
        return this.dataTable.limit;
    }
    set limit(value) {
        this.dataTable.limit = Number(value); // TODO better way to handle that value of number <input> is string?
    }
    get page() {
        return this.dataTable.page;
    }
    set page(value) {
        this.dataTable.page = Number(value);
    }
    createPageRange(number, page) {
        const displayedPage = 3;
        let items = [];
        if (number > 1) {
            let maxPage = number;
            let minPage = 1;
            if (page === 1 && maxPage >= displayedPage) {
                maxPage = 3;
            }
            else if (page > 1 && maxPage > page + 1) {
                minPage = page - 1;
                maxPage = page + 1;
            }
            else if (page > 2 && maxPage > page) {
                minPage = page - 1;
                maxPage = page + 1;
            }
            else if (page > 2 && maxPage === page) {
                minPage = page - 2;
                maxPage = page;
            }
            for (let i = minPage; i <= maxPage; i++) {
                items.push(i);
            }
        }
        return items;
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], DataTablePagination.prototype, "show_range", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DataTablePagination.prototype, "show_limit", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DataTablePagination.prototype, "show_input", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DataTablePagination.prototype, "show_numbers", void 0);
DataTablePagination = __decorate([
    Component({
        selector: 'data-table-pagination',
        template: "<div class=\"pagination-box d-flex justify-content-between\">\n  <div class=\"pagination-range\" *ngIf=\"show_range\">\n    {{ dataTable.translations.paginationRange }}:\n    <span>{{ dataTable.offset + 1 }}</span>\n    -\n    <span>\n      {{ [dataTable.offset + dataTable.limit, dataTable.itemCount] | min }}\n    </span>\n    /\n    <span>{{ dataTable.itemCount }}</span>\n  </div>\n  <div class=\"pagination-controllers d-flex\">\n    <div class=\"pagination-limit\" *ngIf=\"show_limit\">\n      <div class=\"input-group\">\n        <span class=\"input-group-prepend\">\n          <span class=\"input-group-text\">\n            {{ dataTable.translations.paginationLimit }}:\n          </span>\n        </span>\n        <input\n          #limitInput\n          type=\"number\"\n          class=\"form-control\"\n          min=\"1\"\n          step=\"1\"\n          [ngModel]=\"limit\"\n          (blur)=\"limit = limitInput.value\"\n          (keyup.enter)=\"limit = limitInput.value\"\n          (keyup.esc)=\"limitInput.value = limit\"\n        />\n      </div>\n    </div>\n    <div class=\"pagination-pages d-flex\" *ngIf=\"maxPage > 1\">\n      <button\n        [disabled]=\"dataTable.offset <= 0\"\n        (click)=\"pageFirst()\"\n        class=\"btn btn-secondary pagination-firstpage\"\n      >\n        &laquo;\n      </button>\n      <button\n        [disabled]=\"dataTable.offset <= 0\"\n        (click)=\"pageBack()\"\n        class=\"btn btn-secondary pagination-prevpage mx-1\"\n      >\n        &lsaquo;\n      </button>\n      <div class=\"pagination-page\" *ngIf=\"show_input\">\n        <div class=\"input-group\">\n          <input\n            #pageInput\n            type=\"number\"\n            class=\"form-control\"\n            min=\"1\"\n            step=\"1\"\n            max=\"{{ maxPage }}\"\n            [ngModel]=\"page\"\n            (blur)=\"page = pageInput.value\"\n            (keyup.enter)=\"page = pageInput.value\"\n            (keyup.esc)=\"pageInput.value = page\"\n          />\n          <div class=\"input-group-prepend\">\n            <span class=\"input-group-text\">\n              <span>/</span>\n              <span>{{ dataTable.lastPage }}</span>\n            </span>\n          </div>\n        </div>\n      </div>\n      <div class=\"pagination-page\" *ngIf=\"show_numbers\">\n        <button\n          *ngFor=\"let i of createPageRange(maxPage, page)\"\n          [disabled]=\"i == page\"\n          (click)=\"page = i\"\n          class=\"btn btn-default\"\n        >\n          {{ i }}\n        </button>\n      </div>\n      <button\n        [disabled]=\"dataTable.offset + dataTable.limit >= dataTable.itemCount\"\n        (click)=\"pageForward()\"\n        class=\"btn btn-secondary pagination-nextpage mx-1\"\n      >\n        &rsaquo;\n      </button>\n      <button\n        [disabled]=\"dataTable.offset + dataTable.limit >= dataTable.itemCount\"\n        (click)=\"pageLast()\"\n        class=\"btn btn-secondary pagination-lastpage\"\n      >\n        &raquo;\n      </button>\n    </div>\n  </div>\n</div>\n",
        styles: [".pagination-box{position:relative;margin-top:-10px}.pagination-range{display:flex;align-items:center;margin-left:3px}.pagination-range span{margin:0 4px}.pagination-range span:last-child{margin-right:0;margin-left:4px}.pagination-controllers input{min-width:60px;text-align:right}.pagination-limit{margin-right:25px;min-width:150px;max-width:200px}.pagination-page{width:110px}.pagination-reload{color:gray;font-size:12px}"]
    }),
    __param(0, Inject(forwardRef(() => DataTable))),
    __metadata("design:paramtypes", [DataTable])
], DataTablePagination);

let DataTableHeader = class DataTableHeader {
    constructor(dataTable) {
        this.dataTable = dataTable;
        this.columnSelectorOpen = false;
    }
    _closeSelector() {
        this.columnSelectorOpen = false;
    }
};
DataTableHeader = __decorate([
    Component({
        selector: 'data-table-header',
        template: "<div class=\"data-table-header d-flex justify-content-between\">\n  <h4 class=\"title\">{{ dataTable.headerTitle }}</h4>\n  <div class=\"button-panel\">\n    <button\n      type=\"button\"\n      class=\"btn btn-secondary btn-sm refresh-button mr-1\"\n      (click)=\"dataTable.reloadItems()\"\n      [attr.aria-label]=\"dataTable.translations.headerReload\"\n      [title]=\"dataTable.translations.headerReload\"\n    >\n      <span class=\"fa fa-refresh\"></span>\n    </button>\n    <button\n      type=\"button\"\n      class=\"btn btn-secondary btn-sm column-selector-button\"\n      [class.active]=\"columnSelectorOpen\"\n      (click)=\"\n        columnSelectorOpen = !columnSelectorOpen; $event.stopPropagation()\n      \"\n      [attr.aria-label]=\"dataTable.translations.headerColumnSelector\"\n      [title]=\"dataTable.translations.headerColumnSelector\"\n    >\n      <span class=\"fa fa-list\"></span>\n    </button>\n    <div class=\"column-selector-wrapper\" (click)=\"$event.stopPropagation()\">\n      <div *ngIf=\"columnSelectorOpen\" class=\"column-selector-box card\">\n        <div\n          *ngIf=\"dataTable.expandableRows\"\n          class=\"column-selector-fixed-column form-check\"\n        >\n          <input\n            class=\"form-check-input\"\n            type=\"checkbox\"\n            [(ngModel)]=\"dataTable.expandColumnVisible\"\n            id=\"check1\"\n          />\n          <label class=\"form-check-label\" for=\"check1\">\n            {{ dataTable.translations.expandColumn }}\n          </label>\n        </div>\n\n        <div\n          *ngIf=\"dataTable.indexColumn\"\n          class=\"column-selector-fixed-column form-check\"\n        >\n          <input\n            class=\"form-check-input\"\n            type=\"checkbox\"\n            [(ngModel)]=\"dataTable.indexColumnVisible\"\n            id=\"check2\"\n          />\n          <label class=\"form-check-label\" for=\"check2\">\n            {{ dataTable.translations.indexColumn }}\n          </label>\n        </div>\n\n        <div\n          *ngIf=\"dataTable.selectColumn\"\n          class=\"column-selector-fixed-column form-check\"\n        >\n          <input\n            class=\"form-check-input\"\n            type=\"checkbox\"\n            [(ngModel)]=\"dataTable.selectColumnVisible\"\n            id=\"check3\"\n          />\n          <label class=\"form-check-label\" for=\"check3\">\n            {{ dataTable.translations.selectColumn }}\n          </label>\n        </div>\n\n        <div\n          *ngFor=\"let column of dataTable.columns; index as i\"\n          class=\"column-selector-column form-check\"\n        >\n          <input\n            class=\"form-check-input\"\n            type=\"checkbox\"\n            [(ngModel)]=\"column.visible\"\n            [id]=\"'col-check' + i\"\n          />\n          <label class=\"form-check-label\" [for]=\"'col-check' + i\">\n            {{ column.header }}\n          </label>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n",
        host: {
            '(document:click)': '_closeSelector()'
        },
        styles: [".data-table-header{min-height:25px;margin-bottom:10px}.title{margin:5px 0 0 5px}.column-selector-wrapper{position:relative}.column-selector-box{box-shadow:0 0 10px #d3d3d3;width:150px;padding:10px;position:absolute;right:0;top:1px;z-index:1060}.column-selector-fixed-column{font-style:italic}"]
    }),
    __param(0, Inject(forwardRef(() => DataTable))),
    __metadata("design:paramtypes", [DataTable])
], DataTableHeader);

let PixelConverter = class PixelConverter {
    transform(value, args) {
        if (value === undefined) {
            return;
        }
        if (typeof value === 'string') {
            return value;
        }
        if (typeof value === 'number') {
            return value + 'px';
        }
    }
};
PixelConverter = __decorate([
    Pipe({
        name: 'px'
    })
], PixelConverter);

function isBlank(obj) {
    return obj === undefined || obj === null;
}
let Hide = class Hide {
    constructor(_elementRef, _renderer) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._prevCondition = null;
    }
    set hide(newCondition) {
        this.initDisplayStyle();
        if (newCondition &&
            (isBlank(this._prevCondition) || !this._prevCondition)) {
            this._prevCondition = true;
            this._renderer.setElementStyle(this._elementRef.nativeElement, 'display', 'none');
        }
        else if (!newCondition &&
            (isBlank(this._prevCondition) || this._prevCondition)) {
            this._prevCondition = false;
            this._renderer.setElementStyle(this._elementRef.nativeElement, 'display', this._displayStyle);
        }
    }
    initDisplayStyle() {
        if (this._displayStyle === undefined) {
            const displayStyle = this._elementRef.nativeElement.style.display;
            if (displayStyle && displayStyle !== 'none') {
                this._displayStyle = displayStyle;
            }
        }
    }
};
Hide = __decorate([
    Directive({ selector: '[hide]', inputs: ['hide'] }),
    __metadata("design:paramtypes", [ElementRef, Renderer])
], Hide);

let MinPipe = class MinPipe {
    transform(value, args) {
        return Math.min.apply(null, value);
    }
};
MinPipe = __decorate([
    Pipe({
        name: 'min'
    })
], MinPipe);

class DataTableResource {
    constructor(items) {
        this.items = items;
    }
    query(params, filter) {
        let result = [];
        if (filter) {
            result = this.items.filter(filter);
        }
        else {
            result = this.items.slice(); // shallow copy to use for sorting instead of changing the original
        }
        if (params.sortBy) {
            result.sort((a, b) => {
                if (typeof a[params.sortBy] === 'string') {
                    return a[params.sortBy].localeCompare(b[params.sortBy]);
                }
                else {
                    return a[params.sortBy] - b[params.sortBy];
                }
            });
            if (params.sortAsc === false) {
                result.reverse();
            }
        }
        if (params.offset !== undefined) {
            if (params.limit === undefined) {
                result = result.slice(params.offset, result.length);
            }
            else {
                result = result.slice(params.offset, params.offset + params.limit);
            }
        }
        return new Promise((resolve, reject) => {
            setTimeout(() => resolve(result));
        });
    }
    count() {
        return new Promise((resolve, reject) => {
            setTimeout(() => resolve(this.items.length));
        });
    }
}

const DATA_TABLE_DIRECTIVES = [DataTable, DataTableColumn];
let DataTableModule = class DataTableModule {
};
DataTableModule = __decorate([
    NgModule({
        imports: [CommonModule, FormsModule],
        declarations: [
            DataTable,
            DataTableColumn,
            DataTableRow,
            DataTablePagination,
            DataTableHeader,
            PixelConverter,
            Hide,
            MinPipe
        ],
        exports: [DataTable, DataTableColumn]
    })
], DataTableModule);

/**
 * Generated bundle index. Do not edit.
 */

export { DATA_TABLE_DIRECTIVES, DataTable, DataTableColumn, DataTableHeader, DataTableModule, DataTablePagination, DataTableResource, DataTableRow, defaultTranslations, PixelConverter as ɵa, Hide as ɵb, MinPipe as ɵc };
//# sourceMappingURL=ismatjon-angular-data-table.js.map
